Структура проекта
character.h/.cpp
Базовый класс Character

Общие поля и методы для всех персонажей

Принцип Абстракции и Инкапсуляции

heroes.h/.cpp
Классы героев: Archer, Warrior, Mage

Наследуют от Character

Переопределяют виртуальные методы

monsters.h/.cpp
Классы монстров: Ogre, Dragon, Ghost

Также наследуют от Character

Демонстрация Полиморфизма

main.cpp
Демонстрация всех принципов

Игровая ситуация

Работа с разными типами через один интерфейс

Основные принципы ООП в коде
1. Инкапсуляция
Поля private/protected

Доступ через публичные методы

Проверка корректности данных

2. Наследование
class Archer : public Character

Переиспользование кода

Расширение функциональности

3. Полиморфизм
Виртуальные функции

override для переопределения

Обработка разных типов через Character*

4. Абстракция
Интерфейс класса скрывает реализацию

Важно ЧТО делает, а не КАК делает

Чисто виртуальные методы

Задания для самостоятельной работы
Добавить нового героя Priest (Жрец)

Добавить нового монстра Vampire (Вампир)

Реализовать систему инвентаря

Добавить поле experience (опыт)

Создать систему уровней персонажей

text

## Краткое объяснение для студентов:

### Что такое класс?
Класс = Шаблон для создания объектов
Пример:
Класс "Автомобиль" - чертеж
Объект "Моя машина" - конкретный автомобиль

text

### 4 принципа ООП:

1. **Инкапсуляция** - сокрытие деталей
   ```cpp
   private: int health;  // Нельзя напрямую изменить
   public: void heal(int amount);  // Контролируемое изменение
Наследование - повторное использование

cpp
class Archer : public Character {
    // Получает все поля и методы Character
    // Добавляет свои (arrows)
};
Полиморфизм - разные типы, один интерфейс

cpp
Character* c1 = new Archer("Legolas", 5);
Character* c2 = new Dragon("Smaug", 10);
c1->attack(target);  // Стреляет из лука
c2->attack(target);  // Дышит огнем
Абстракция - сокрытие сложности

cpp
// Пользователю не важно как именно лечится персонаж
// Важно что он может лечиться
character.heal(50);
Этот проект специально создан для обучения:

Каждый файл имеет четкое назначение

Код хорошо документирован

Принципы ООП показаны наглядно

Можно легко расширять и модифицировать