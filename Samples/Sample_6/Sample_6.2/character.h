// ============================================================================
// ФАЙЛ: character.h - ОБЪЯВЛЕНИЕ БАЗОВОГО КЛАССА
// ============================================================================
// ЗАЧЕМ НУЖНЫ .h ФАЙЛЫ?
// 1. Объявление классов (что они делают)
// 2. Описание интерфейсов (как с ними работать)
// 3. Включение в другие файлы (#include)
// ============================================================================

#pragma once  // Защита от повторного включения
#include <string>
#include <iostream>
#include <memory>  // Для умных указателей

// ============================================================================
// ПРИНЦИП ООП №1: АБСТРАКЦИЯ (Abstraction)
// ============================================================================
// АБСТРАКЦИЯ - выделение существенных характеристик объекта
// и игнорирование несущественных деталей.
// 
// В нашем случае:
// - Персонаж абстрагирован до характеристик: имя, уровень, здоровье
// - Не важно как именно он выглядит или где находится
// - Важно что он умеет делать: атаковать, лечиться, получать урон
// ============================================================================

// Базовый абстрактный класс "Персонаж"
// abstract class = нельзя создать объект этого класса напрямую
class Character {
// ============================================================================
// ПРИНЦИП ООП №2: ИНКАПСУЛЯЦИЯ (Encapsulation)
// ============================================================================
// ИНКАПСУЛЯЦИЯ - сокрытие внутренней реализации и защита данных.
// 
// Доступ к полям контролируется через методы (геттеры/сеттеры).
// Три уровня доступа:
// 1. private - доступ только внутри класса
// 2. protected - доступ внутри класса и наследников
// 3. public - доступ откуда угодно
// 
// ПОЧЕМУ ЭТО ВАЖНО?
// 1. Защита от некорректных данных (health не может быть отрицательным)
// 2. Возможность изменить реализацию без изменения интерфейса
// 3. Упрощение использования (пользователь не знает о сложностях внутри)
// ============================================================================
protected:  // Доступно классу и наследникам, но не извне
    std::string name;    // Имя персонажа
    int level;           // Уровень
    int health;          // Текущее здоровье
    int maxHealth;       // Максимальное здоровье
    bool isAlive;        // Жив ли персонаж
    
    // Защищенный метод - используется наследниками
    void calculateMaxHealth();

public:  // Открытый интерфейс - доступен всем
    // ========================================================================
    // КОНСТРУКТОРЫ И ДЕСТРУКТОР
    // ========================================================================
    Character(const std::string& name, int level);
    virtual ~Character() = default;  // Виртуальный деструктор для полиморфизма
    
    // ========================================================================
    // ПРИНЦИП ИНКАПСУЛЯЦИИ: ГЕТТЕРЫ (getters)
    // ========================================================================
    // Предоставляют доступ к полям без возможности их изменения
    std::string getName() const { return name; }
    int getLevel() const { return level; }
    int getHealth() const { return health; }
    bool getIsAlive() const { return isAlive; }
    
    // ========================================================================
    // ОСНОВНЫЕ МЕТОДЫ (интерфейс класса)
    // ========================================================================
    void heal(int amount);               // Лечение
    virtual void takeDamage(int damage); // Получение урона (виртуальный!)
    virtual void attack(Character* target); // Атака (виртуальный!)
    
    // ========================================================================
    // ПРИНЦИП ООП №3: ПОЛИМОРФИЗМ (Polymorphism)
    // ========================================================================
    // ПОЛИМОРФИЗМ - возможность объектов разных типов обрабатываться
    // через единый интерфейс.
    //
    // virtual - метод может быть переопределен в наследниках
    // override - явное указание что переопределяем (C++11 и выше)
    // 
    // Два вида полиморфизма:
    // 1. Статический (перегрузка функций) - compile time
    // 2. Динамический (виртуальные функции) - runtime
    // ========================================================================
    virtual void specialAbility() = 0;  // Чисто виртуальный метод
    
    // Виртуальный метод с реализацией по умолчанию
    virtual std::string getType() const { return "Персонаж"; }
    
    // ========================================================================
    // СТАТИЧЕСКИЕ МЕТОДЫ И ПОЛЯ
    // ========================================================================
    // Принадлежат классу, а не объекту. Существуют в единственном экземпляре.
    static int totalCharactersCreated;  // Статическое поле
    
    static void printGameRules() {
        std::cout << "\n=== ПРАВИЛА ИГРЫ ===\n";
        std::cout << "1. Персонажи атакуют друг друга\n";
        std::cout << "2. Здоровье <= 0 = смерть\n";
        std::cout << "3. Лечение восстанавливает здоровье\n";
    }
};
// ============================================================================
// КОНЕЦ ОБЪЯВЛЕНИЯ КЛАССА
// ============================================================================