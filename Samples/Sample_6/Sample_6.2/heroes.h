// ============================================================================
// ФАЙЛ: heroes.h - КЛАССЫ ГЕРОЕВ
// ============================================================================
// ПРИНЦИП ООП №4: НАСЛЕДОВАНИЕ (Inheritance)
// ============================================================================
// НАСЛЕДОВАНИЕ - создание нового класса на основе существующего.
// Новый класс (наследник) получает все поля и методы родительского класса.
// 
// Отношение "является" (is-a):
// - "Лучник является Персонажем" (Archer is a Character)
// - "Воин является Персонажем" (Warrior is a Character)
// 
// ВИДЫ НАСЛЕДОВАНИЯ:
// 1. public - интерфейс родителя становится интерфейсом наследника
// 2. protected - публичные методы родителя становятся protected
// 3. private - все методы родителя становятся private
// 
// В 99% случаев используется public наследование!
// ============================================================================

#pragma once
#include "character.h"

// ============================================================================
// КЛАСС ЛУЧНИК - НАСЛЕДУЕТ ОТ CHARACTER
// ============================================================================
class Archer : public Character {  // public наследование
private:
    int arrows;  // Дополнительное поле - только для лучника
    
public:
    Archer(const std::string& name, int level);
    
    // ========================================================================
    // ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ (ПОЛИМОРФИЗМ)
    // ========================================================================
    void attack(Character* target) override;  // Особая атака лучника
    void specialAbility() override;           // Реализация чисто виртуального метода
    std::string getType() const override { return "Лучник"; }
    
    // Специфичный метод для лучника
    void shootArrow(Character* target);
};

// ============================================================================
// КЛАСС ВОИН - НАСЛЕДУЕТ ОТ CHARACTER
// ============================================================================
class Warrior : public Character {
private:
    int armor;  // Броня - уменьшает получаемый урон
    
public:
    Warrior(const std::string& name, int level);
    
    // ========================================================================
    // ПЕРЕОПРЕДЕЛЕНИЕ И РАСШИРЕНИЕ ФУНКЦИОНАЛА
    // ========================================================================
    void takeDamage(int damage) override;  // Воин получает меньше урона
    void attack(Character* target) override;
    void specialAbility() override;
    std::string getType() const override { return "Воин"; }
    
    // Специфичные методы воина
    void block();  // Блокировка атаки
};

// ============================================================================
// КЛАСС МАГ - НАСЛЕДУЕТ ОТ CHARACTER
// ============================================================================
class Mage : public Character {
private:
    int mana;       // Мана - ресурс для заклинаний
    int maxMana;    // Максимальная мана
    
    void calculateMaxMana();  // Скрытый метод
    
public:
    Mage(const std::string& name, int level);
    
    // ========================================================================
    // ПОЛНОЕ ПЕРЕОПРЕДЕЛЕНИЕ ПОВЕДЕНИЯ
    // ========================================================================
    void attack(Character* target) override;  // Атака требует ману
    void takeDamage(int damage) override;     // Маг хрупкий
    void specialAbility() override;
    std::string getType() const override { return "Маг"; }
    
    // Специфичные методы мага
    void castSpell(Character* target);
    void restoreMana(int amount);
    
    // Геттер для маны
    int getMana() const { return mana; }
};
// ============================================================================
// КОНЕЦ ОБЪЯВЛЕНИЯ КЛАССОВ ГЕРОЕВ
// ============================================================================