// ============================================================================
// ФАЙЛ: character.cpp - РЕАЛИЗАЦИЯ БАЗОВОГО КЛАССА
// ============================================================================
// ЗАЧЕМ НУЖНЫ .cpp ФАЙЛЫ?
// 1. Реализация методов, объявленных в .h
// 2. Сокрытие деталей реализации
// 3. Ускорение компиляции
// ============================================================================

#include "character.h"

// Инициализация статического поля
// Существует в единственном экземпляре для всего класса
int Character::totalCharactersCreated = 0;

// ============================================================================
// РЕАЛИЗАЦИЯ КОНСТРУКТОРА
// ============================================================================
Character::Character(const std::string& name, int level)
    : name(name), level(level), isAlive(true) {
    
    // Инициализация полей
    calculateMaxHealth();  // Вычисляем максимальное здоровье
    health = maxHealth;    // Начинаем с полного здоровья
    
    // Увеличиваем счетчик созданных персонажей
    totalCharactersCreated++;
    
    std::cout << "[СИСТЕМА] Создан " << getType() << " " 
              << name << " (ур. " << level << ")\n";
}

// ============================================================================
// ПРИНЦИП ИНКАПСУЛЯЦИИ: СКРЫТАЯ РЕАЛИЗАЦИЯ
// ============================================================================
// Метод protected - виден только классу и наследникам
// Пользователь не знает как вычисляется здоровье
void Character::calculateMaxHealth() {
    // Базовая формула: 50 + (уровень * 10)
    maxHealth = 50 + (level * 10);
}

// ============================================================================
// РЕАЛИЗАЦИЯ МЕТОДА ЛЕЧЕНИЯ
// ============================================================================
// Демонстрация инкапсуляции:
// 1. Проверка корректности данных
// 2. Защита от переполнения здоровья
void Character::heal(int amount) {
    if (!isAlive) {
        std::cout << name << " мертв и не может лечиться!\n";
        return;
    }
    
    if (amount <= 0) {
        std::cout << "Нельзя лечиться на " << amount << " HP!\n";
        return;
    }
    
    health += amount;
    
    // Защита от превышения максимального здоровья
    if (health > maxHealth) {
        health = maxHealth;
    }
    
    std::cout << " -> " << name << " восстановил " << amount 
              << " HP. Теперь: " << health << "/" << maxHealth << " HP\n";
}

// ============================================================================
// РЕАЛИЗАЦИЯ МЕТОДА ПОЛУЧЕНИЯ УРОНА
// ============================================================================
// Виртуальный метод с базовой реализацией
// Наследники могут переопределить это поведение
void Character::takeDamage(int damage) {
    if (!isAlive) {
        std::cout << name << " уже мертв!\n";
        return;
    }
    
    if (damage <= 0) {
        std::cout << "Нельзя получить " << damage << " урона!\n";
        return;
    }
    
    health -= damage;
    std::cout << " -> " << name << " получает " << damage << " урона. ";
    
    if (health <= 0) {
        health = 0;
        isAlive = false;
        std::cout << name << " погиб!\n";
        
        // Уменьшаем счетчик живых персонажей
        totalCharactersCreated--;
    } else {
        std::cout << "Осталось " << health << "/" << maxHealth << " HP\n";
    }
}

// ============================================================================
// РЕАЛИЗАЦИЯ МЕТОДА АТАКИ
// ============================================================================
// Базовая реализация атаки
// Наследники переопределят этот метод для особого поведения
void Character::attack(Character* target) {
    if (!isAlive) {
        std::cout << name << " мертв и не может атаковать!\n";
        return;
    }
    
    if (target == nullptr) {
        std::cout << "Нельзя атаковать пустую цель!\n";
        return;
    }
    
    if (!target->getIsAlive()) {
        std::cout << name << " не может атаковать мертвого " 
                  << target->getName() << "!\n";
        return;
    }
    
    // Базовая формула урона
    int damage = level * 3;
    
    std::cout << " -> " << name << " атакует " << target->getName() 
              << " и наносит " << damage << " урона\n";
    
    target->takeDamage(damage);
}
// ============================================================================
// КОНЕЦ РЕАЛИЗАЦИИ БАЗОВОГО КЛАССА
// ============================================================================
